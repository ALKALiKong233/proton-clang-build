From 1cebeb2cec2bbd3a1d74619d8b765bcc49159aac Mon Sep 17 00:00:00 2001
From: Danny Lin <danny@kdrag0n.dev>
Date: Mon, 5 Aug 2019 21:23:43 +0000
Subject: [PATCH 1/2] D65304: Don't recreate a label if it's already used

Signed-off-by: Danny Lin <danny@kdrag0n.dev>
---
 llvm/include/llvm/MC/MCContext.h              | 15 +++++
 .../AsmPrinter/AsmPrinterInlineAsm.cpp        |  1 +
 llvm/lib/MC/MCContext.cpp                     |  2 +
 llvm/lib/MC/MCParser/AsmParser.cpp            |  4 +-
 llvm/test/CodeGen/AArch64/callbr-asm-label.ll | 63 +++++++++++++++++++
 .../test/CodeGen/X86/callbr-asm-label-addr.ll | 30 +++++++++
 llvm/test/CodeGen/X86/callbr-asm.ll           | 16 ++---
 7 files changed, 122 insertions(+), 9 deletions(-)
 create mode 100644 llvm/test/CodeGen/AArch64/callbr-asm-label.ll
 create mode 100644 llvm/test/CodeGen/X86/callbr-asm-label-addr.ll

diff --git a/llvm/include/llvm/MC/MCContext.h b/llvm/include/llvm/MC/MCContext.h
index 7e24292cdd1..aa9a612bb7d 100644
--- a/llvm/include/llvm/MC/MCContext.h
+++ b/llvm/include/llvm/MC/MCContext.h
@@ -112,6 +112,9 @@ namespace llvm {
     /// number of section symbols with the same name).
     StringMap<bool, BumpPtrAllocator &> UsedNames;
 
+    /// Keeps track of labels that are used in inline assembly.
+    SymbolTable InlineAsmUsedLabelNames;
+
     /// The next ID to dole out to an unnamed assembler temporary symbol with
     /// a given prefix.
     StringMap<unsigned> NextID;
@@ -377,6 +380,18 @@ namespace llvm {
     /// APIs.
     const SymbolTable &getSymbols() const { return Symbols; }
 
+    /// isInlineAsmLabel - Return true if the name is a label referenced in
+    /// inline assembly.
+    MCSymbol *getInlineAsmLabel(StringRef Name) const {
+      return InlineAsmUsedLabelNames.lookup(Name);
+    }
+
+    /// registerInlineAsmLabel - Records that the name is a label referenced in
+    /// inline assembly.
+    void registerInlineAsmLabel(StringRef Name, MCSymbol *Sym) {
+      InlineAsmUsedLabelNames[Name] = Sym;
+    }
+
     /// @}
 
     /// \name Section Management
diff --git a/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp b/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
index 7721e996aca..5560cfb8792 100644
--- a/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
+++ b/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
@@ -432,6 +432,7 @@ static void EmitGCCInlineAsmStr(const char *AsmStr, const MachineInstr *MI,
               const BlockAddress *BA = MI->getOperand(OpNo).getBlockAddress();
               MCSymbol *Sym = AP->GetBlockAddressSymbol(BA);
               Sym->print(OS, AP->MAI);
+              MMI->getContext().registerInlineAsmLabel(Sym->getName(), Sym);
             } else if (MI->getOperand(OpNo).isMBB()) {
               const MCSymbol *Sym = MI->getOperand(OpNo).getMBB()->getSymbol();
               Sym->print(OS, AP->MAI);
diff --git a/llvm/lib/MC/MCContext.cpp b/llvm/lib/MC/MCContext.cpp
index ecd12fdc689..1c48aeeecbc 100644
--- a/llvm/lib/MC/MCContext.cpp
+++ b/llvm/lib/MC/MCContext.cpp
@@ -61,6 +61,7 @@ MCContext::MCContext(const MCAsmInfo *mai, const MCRegisterInfo *mri,
                      bool DoAutoReset)
     : SrcMgr(mgr), InlineSrcMgr(nullptr), MAI(mai), MRI(mri), MOFI(mofi),
       Symbols(Allocator), UsedNames(Allocator),
+      InlineAsmUsedLabelNames(Allocator),
       CurrentDwarfLoc(0, 0, 0, DWARF2_FLAG_IS_STMT, 0, 0),
       AutoReset(DoAutoReset) {
   SecureLogFile = AsSecureLogFileName;
@@ -90,6 +91,7 @@ void MCContext::reset() {
   XCOFFAllocator.DestroyAll();
 
   MCSubtargetAllocator.DestroyAll();
+  InlineAsmUsedLabelNames.clear();
   UsedNames.clear();
   Symbols.clear();
   Allocator.Reset();
diff --git a/llvm/lib/MC/MCParser/AsmParser.cpp b/llvm/lib/MC/MCParser/AsmParser.cpp
index a3d6014dc31..3d4e207b038 100644
--- a/llvm/lib/MC/MCParser/AsmParser.cpp
+++ b/llvm/lib/MC/MCParser/AsmParser.cpp
@@ -1157,7 +1157,9 @@ bool AsmParser::parsePrimaryExpr(const MCExpr *&Res, SMLoc &EndLoc) {
       }
     }
 
-    MCSymbol *Sym = getContext().getOrCreateSymbol(SymbolName);
+    MCSymbol *Sym = getContext().getInlineAsmLabel(SymbolName);
+    if (!Sym)
+      Sym = getContext().getOrCreateSymbol(SymbolName);
 
     // If this is an absolute variable reference, substitute it now to preserve
     // semantics in the face of reassignment.
diff --git a/llvm/test/CodeGen/AArch64/callbr-asm-label.ll b/llvm/test/CodeGen/AArch64/callbr-asm-label.ll
new file mode 100644
index 00000000000..1287df5fb02
--- /dev/null
+++ b/llvm/test/CodeGen/AArch64/callbr-asm-label.ll
@@ -0,0 +1,63 @@
+; RUN: llc < %s -mtriple=armv4t-unknown-linux-gnueabi | FileCheck %s
+
+@X = common local_unnamed_addr global i32 0, align 4
+
+define i32 @test1() {
+; CHECK-LABEL: test1:
+; CHECK:         .long b
+; CHECK-NEXT:    .long .Ltmp0
+; CHECK-LABEL: .Ltmp0:
+; CHECK-LABEL: .LBB0_1: @ %l_yes
+; CHECK-LABEL: .LBB0_2: @ %cleanup
+entry:
+  callbr void asm sideeffect "1:\0A\09.word b, ${0:l}\0A\09", "X"(i8* blockaddress(@test1, %l_yes))
+          to label %cleanup [label %l_yes]
+
+l_yes:
+  br label %cleanup
+
+cleanup:
+  %retval.0 = phi i32 [ 1, %l_yes ], [ 0, %entry ]
+  ret i32 %retval.0
+}
+
+define void @test2() {
+; CHECK-LABEL: test2:
+entry:
+  %0 = load i32, i32* @X, align 4
+  %and = and i32 %0, 1
+  %tobool = icmp eq i32 %and, 0
+  br i1 %tobool, label %if.end10, label %if.then
+
+if.then:
+; CHECK:       .long b
+; CHECK-NEXT:  .long .Ltmp2
+; CHECK-LABEL: .Ltmp2:
+; CHECK-NEXT:  .LBB1_3: @ %if.end6
+  callbr void asm sideeffect "1:\0A\09.word b, ${0:l}\0A\09", "X"(i8* blockaddress(@test2, %if.end6))
+          to label %if.then4 [label %if.end6]
+
+if.then4:
+  %call5 = tail call i32 bitcast (i32 (...)* @g to i32 ()*)()
+  br label %if.end6
+
+if.end6:
+  %.pre = load i32, i32* @X, align 4
+  %.pre13 = and i32 %.pre, 1
+  %phitmp = icmp eq i32 %.pre13, 0
+  br i1 %phitmp, label %if.end10, label %if.then9
+
+if.then9:
+; CHECK-LABEL: .Ltmp4:
+; CHECK-NEXT:  .LBB1_5: @ %l_yes
+  callbr void asm sideeffect "", "X"(i8* blockaddress(@test2, %l_yes))
+          to label %if.end10 [label %l_yes]
+
+if.end10:
+  br label %l_yes
+
+l_yes:
+  ret void
+}
+
+declare i32 @g(...)
diff --git a/llvm/test/CodeGen/X86/callbr-asm-label-addr.ll b/llvm/test/CodeGen/X86/callbr-asm-label-addr.ll
new file mode 100644
index 00000000000..dc0e8363465
--- /dev/null
+++ b/llvm/test/CodeGen/X86/callbr-asm-label-addr.ll
@@ -0,0 +1,30 @@
+; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu | FileCheck %s
+
+define i32 @test1(i32 %x) {
+; CHECK-LABEL: test1:
+; CHECK:         .quad .Ltmp0
+; CHECK-NEXT:    .quad .Ltmp1
+; CHECK-LABEL: .Ltmp1:
+; CHECK-LABEL: .LBB0_1: # %bar
+; CHECK-NEXT:    callq foo
+; CHECK-LABEL: .Ltmp0:
+; CHECK-NEXT:  # %bb.2: # %baz
+entry:
+  callbr void asm sideeffect ".quad ${0:l}\0A\09.quad ${1:l}", "i,X,~{dirflag},~{fpsr},~{flags}"(i8* blockaddress(@test1, %baz), i8* blockaddress(@test1, %bar))
+          to label %asm.fallthrough [label %bar]
+
+asm.fallthrough:
+  br label %bar
+
+bar:
+  %call = tail call i32 @foo(i32 %x)
+  br label %baz
+
+baz:
+  %call1 = tail call i32 @mux(i32 %call)
+  ret i32 %call1
+}
+
+declare i32 @foo(i32)
+
+declare i32 @mux(i32)
diff --git a/llvm/test/CodeGen/X86/callbr-asm.ll b/llvm/test/CodeGen/X86/callbr-asm.ll
index 48a80ae167b..ed3c314ed42 100644
--- a/llvm/test/CodeGen/X86/callbr-asm.ll
+++ b/llvm/test/CodeGen/X86/callbr-asm.ll
@@ -12,7 +12,7 @@ define i32 @test1(i32 %a) {
 ; CHECK-NEXT:    addl $4, %eax
 ; CHECK-NEXT:    #APP
 ; CHECK-NEXT:    xorl %eax, %eax
-; CHECK-NEXT:    jmp .Ltmp00
+; CHECK-NEXT:    jmp .Ltmp0
 ; CHECK-NEXT:    #NO_APP
 ; CHECK-NEXT:  .LBB0_1: # %normal
 ; CHECK-NEXT:    xorl %eax, %eax
@@ -87,17 +87,17 @@ define dso_local i32 @test3(i32 %a) {
 ; CHECK-NEXT:    # Parent Loop BB2_3 Depth=3
 ; CHECK-NEXT:    # => This Inner Loop Header: Depth=4
 ; CHECK-NEXT:    #APP
-; CHECK-NEXT:    jmp .Ltmp10
-; CHECK-NEXT:    jmp .Ltmp20
-; CHECK-NEXT:    jmp .Ltmp30
+; CHECK-NEXT:    jmp .Ltmp1
+; CHECK-NEXT:    jmp .Ltmp2
+; CHECK-NEXT:    jmp .Ltmp3
 ; CHECK-NEXT:    #NO_APP
 ; CHECK-NEXT:  .LBB2_5: # %normal0
 ; CHECK-NEXT:    # in Loop: Header=BB2_4 Depth=4
 ; CHECK-NEXT:    #APP
-; CHECK-NEXT:    jmp .Ltmp10
-; CHECK-NEXT:    jmp .Ltmp20
-; CHECK-NEXT:    jmp .Ltmp30
-; CHECK-NEXT:    jmp .Ltmp40
+; CHECK-NEXT:    jmp .Ltmp1
+; CHECK-NEXT:    jmp .Ltmp2
+; CHECK-NEXT:    jmp .Ltmp3
+; CHECK-NEXT:    jmp .Ltmp4
 ; CHECK-NEXT:    #NO_APP
 ; CHECK-NEXT:  .LBB2_6: # %normal1
 ; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax
-- 
2.20.1

